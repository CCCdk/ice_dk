# 函数的基本使用以及封装练习

## 为什么需要函数

- 函数

**function**：是被设计为**执行特定任务**的代码块。

- 说明

函数可以把具有相同或相似逻辑的代码"包裹"起来，通过函数调用执行这些被"包裹"的代码逻辑，这么做的优势是有利于**精简代码方便复用**。

## 语法

```javascript
function 函数名(参数列表){
    函数体
}
```

**函数名命名规范**：

- 和变量名基本一致
- 尽量小驼峰命名法
- 前缀应该为动词
- 命名建议：常用动词约定
  1. **can**     判断是否可执行某个动作
  2. **has**     判断是否含义某一个值
  3. **is**        判断是否为某个值
  4. **get**      获取某个值
  5. **set**      设置某个值
  6. **load**    加载某些数据

## 函数调用

- **函数的调用方法**

```js
函数名()
```

**声明(定义)的函数必须调用才会真正被执行，使用()调用函数**。

## 函数传参

**调用函数时，需要传入几个数据就写几个，用逗号隔开**。

## 默认参数

一个不传递参数，那个形参是undefined，我们需对其进行改进，**给形参默认值**，可以默认为0什么的，这样程序更严谨。

![默认值](..\js学习\图片\默认值.png)

## 函数返回值

- 当调用某个函数，这个函数会返回一个结果出来，这就是有**返回值**的函数。

**并不是所有函数都需要返回值**

```js
return 返回值
```

## 一些细节

- 在函数体中使用return关键字能将内部的执行结果交给函数外部使用
- return后面代码不会再被执行，会立即结束当前函数，所以**return后面的数据不要换行写**。
- return函数可以没有return，这种情况函数默认返回值为undefined

## 作用域

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的**可用性的代码范围**就是这个名字的**作用域**。

该使用能够**提高程序逻辑的局部性**，增强了程序的可靠性，减少了名字冲突。

- 全局作用域

作用于所有代码执行的环境（整个script标签内部）或者一个独立的js文件。

- 局部作用域

作用于函数内的代码环境，就是局部作用域。因为跟函数有关系，所以也称为函数作用域。

## 变量

### 全局变量

函数外部let的变量：全局变量在任何区域都可以访问和修改

### 局部变量

局部变量只能在当前函数内部访问和修改

## 访问原则

- 只要是代码，就至少有一个作用域
- 写在函数内部的局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
- 访问原则：**在能够访问到的情况下，先局部，局部没有在招全局**。

## 具名和匿名函数

- **具名函数**：

```js
声明：function fn(){}
调用：fn()
```

- **匿名函数**：

```js
function() {}
```

使用方式：

1. 函数表达式

将匿名函数赋值给一个变量，并且通过变量名称进行调用，我们将这个称为**函数表达式**。

```js
let fn=function(){
    //函数体
}
```

2. 立即执行函数(**必须加分号**)

避免全局变量之间的污染。

```js
(function () {})()
(function () {}())
```

# 逻辑中断

## 逻辑运算符里的短路

短路：**只存在于&&和||中，当满足一定条件会让右边代码不执行**。

```js
function fn(x,y){
    x= x || 0
    y= y || 0
    console.log(x,y)
}
```

**原因**：通过左边能得到整个式子的结果，因此没必要再判断右边。

**运算结果**：无论&&还是| |，运算结果都是最后被执行的表达式值，一般用在变量赋值。

# 转换为布尔值

## 显示转换：

为假的：**0**，**undefined**，**null**，**NaN**，其余则为true。

## 隐式转换：

1. 有字符串的加法 ""+1，结果是"1"。
2. 减法 - (像大多数数学运算一样)，只能用于数字，它会使空字符串""转换为0。
3. null经过数字转换之后会变为0。
4. undefined经过数字转换之后会变为NaN。

# 断点调试

进入函数内部执行过程  **按F11**。

