# 作用域

- 作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问。
- 作用域分为：局部作用域，全局作用域

## 局部作用域

局部作用域分为函数作用域和块作用域。

1. **函数作用域**：在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。

2. **块作用域**：在JavaScript中使用{}包裹的代码称为代码块，代码块内部声明的变量外部将[**有可能**]无法被访问
   - let声明的变量会产生块作用域，var不会产生块作用域
   - const声明的常量也会产生块作用域
   - 不同代码之间的变量无法互相访问
   - 推荐使用let或const

```js
for(let t=1;t<=6;t++){
    //t只能在该代码块中被访问
    console.log(t)//正常
}
//超过了t的作用域
console.log(t)//报错
```



## 全局作用域

**<script>标签**和**.js文件**的[最外层]就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。

全局作用域中声明的变量，任何其他作用域都可以被访问

```js
<script>
    //全局作用域
    //全局作用域下声明了num变量
    const num=10
    function fn(){
        //函数内部可以使用全局作用域的变量
        console.log(num)
    } 
</script>
```

**注意**：

1. 为window对象动态添加的属性默认也是全局的，不推荐！！
2. 函数中未使用任何关键字声明的变量为全局变量，不推荐！！
3. 尽可能少的声明全局变量，防止全局变量被污染

## 作用域链

作用域链本质上最底层的**变量查找机制**。

- 在函数被执行时，会**优先查找当前**函数作用域中查找变量
- 如果当前作用域查找不到则会依次**逐级查找父级作用域**直到全局作用域

## JS垃圾回收机制

**垃圾回收机制（Garbage Collection）简称GC**。

JS中**内存**的分配和回收都是**自动完成**的，内存在不使用的时候会被**垃圾回收器**自动回收

### 内存的生命周期

JS环境中分配的内存，一般有如下**生命周期**：

1. **内存分配**：当我们声明变量，函数，对象的时候，系统会自动为他们分配内存
2. **内存使用**：即读写内存，也就是使用变量，函数等
3. **内存回收**：使用完毕，由**垃圾回收器**自动回收不再使用的内存

**说明：**

- 全局变量一般不会回收（关闭页面回收）
- 一般情况下**局部变量的值**，不用了，会被**自动回收**掉

**内存泄漏**：程序中分配的**内存**由于某种原因程序**未释放**或**无法释放**叫做**内存泄漏**。

### 算法说明

堆栈空间分配区别

1. 栈（操作系统）：由**操作系统自动分配释放**函数的参数值，局部变量等，基本数据类型放到栈里面。
2. 堆（操作系统）：一般由程序员分配释放，若程序员不释放，由**垃圾回收机制**回收，**复杂数据类型**放到堆里面

常见的两种浏览器**垃圾回收算法**：**引用计数法**和**标记清除法**。

#### 引用计数

IE采用的引用计数算法，定义"内存不再使用"，就是看一个**对象**是否指向它的引用，没有引用了就回收对象

**算法**：

1. 跟踪记录被**引用的次数**。
2. 如果被引用了一次，那么就记录次数1，多次引用会**累加 ++**
3. 如果减少一个引用就**减1 --**
4. 如果引用次数是**0**，则释放内存

但它有一个致命的问题：**嵌套引用**（循环引用）

如果两个对象**相互引用**，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏

```js
function fn(){
    let o1={}
    let o2={}
    o1.a=o2
    o2.a=o1
    return '引用计数无法回收'
}
```

因为他们的引用次数永远不会是0.这样的相互引用如果说很大量的存在就会导致大量的内存泄漏

#### 标记清除法

现在的浏览器已经不再引用计数算法了，大多是基于**标记清除算法**的某些改进算法，总体思想都是一致的

**核心**：

1. 标记清除算法将“不再使用的对象”定义为“无法达到的对象”
2. 就是从**根部**（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从**根部到达**的对象，都是还**需要使用**的。
3. 那些**无法**由根部出发触及到的**对象被标记**为不再使用，稍后进行**回收**。



## 闭包

**概念**：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

**简单理解**：闭包=内层函数+外层函数的变量

```js
//简单的写法
fuction outer(){
    const a=1
    function f(){
        console.log(a)
    }
    f()
}
outer()
```

**闭包作用**：封闭数据，提供操作，外部也可以访问函数内部的变量

**闭包的基本格式**：

```js
fuction outer(){
    let a=1
    function fn(){
        console.log(a)
    }
    return fn
}
const fun=outer()
fun() //1
//外层函数使用内部函数的变量
```

### 闭包应用

- 实现数据的私有

 ![闭包应用](.\图片\闭包应用.png)



## 变量提升

当代码执行之前，会把所有var声明的变量提升到当前作用域的最前面，但**只提升声明**，**不提升赋值**，值为undefined。



# 函数进阶

## 函数提升

会把所有函数声明提升到当前作用域的最前面

只提升函数声明，不提升函数调用



## 函数参数

函数参数的使用细节，能够提升函数应用的灵活度

### 动态参数



### 剩余参数



## 箭头函数



# 解构赋值



# 综合案例





